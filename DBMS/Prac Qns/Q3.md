```
3. Customer => (cust_id, cust_name, mobno, email, city)

Order => (order_id, product_type, delivery_date, status, amtpaid, cust_id)

Create two tables as per given structure and execute followings.

a. A Trigger to maintain LOG based on DELETE operation on order table.

b. Display the names of all the customers whose email has 'a' as second letter.

c. Display cust_ids of those who haven't placed any order.

d. Apply 5% discount on 'amtpaid' for all customers
```


Complete Solution for Customer-Order Database System

üìå STEP 1: CREATE TABLES WITH PROPER STRUCTURE

```sql
-- Create Customer table
CREATE TABLE Customer (
    cust_id INT PRIMARY KEY,
    cust_name VARCHAR(100) NOT NULL,
    mobno VARCHAR(15),
    email VARCHAR(100),
    city VARCHAR(50)
);

-- Create Order table (using quotes as ORDER is reserved word)
CREATE TABLE "Order" (
    order_id INT PRIMARY KEY,
    product_type VARCHAR(50),
    delivery_date DATE,
    status VARCHAR(20) DEFAULT 'Pending',
    amtpaid DECIMAL(10, 2) CHECK (amtpaid >= 0),
    cust_id INT,
    FOREIGN KEY (cust_id) REFERENCES Customer(cust_id)
);
```

üìå STEP 2: INSERT SAMPLE DATA

```sql
-- Insert Customer Data
INSERT INTO Customer (cust_id, cust_name, mobno, email, city) VALUES
(1, 'John Smith', '9876543210', 'jsmith@gmail.com', 'New York'),
(2, 'Sarah Johnson', '8765432109', 'sarahj@yahoo.com', 'Los Angeles'),
(3, 'Michael Brown', '7654321098', 'mbrown@hotmail.com', 'Chicago'),
(4, 'Alice Williams', '6543210987', 'alice.w@example.com', 'Houston'),
(5, 'Robert Davis', '5432109876', 'rdavis@gmail.com', 'Phoenix'),
(6, 'Emma Wilson', '4321098765', 'emma@test.com', 'Philadelphia'),
(7, 'David Taylor', '3210987654', 'dtaylor@demo.com', 'San Antonio'),
(8, 'Amanda Clark', '2109876543', 'aclark@email.com', 'San Diego'),
(9, 'Frank Miller', '1098765432', 'fmiller@domain.com', 'Dallas'),
(10, 'Grace Lee', '0987654321', 'glee@server.com', 'Austin');

-- Insert Order Data
INSERT INTO "Order" (order_id, product_type, delivery_date, status, amtpaid, cust_id) VALUES
(101, 'Electronics', '2024-02-15', 'Delivered', 500.00, 1),
(102, 'Books', '2024-02-20', 'Shipped', 150.00, 1),
(103, 'Clothing', '2024-02-25', 'Pending', 200.00, 2),
(104, 'Furniture', '2024-03-01', 'Processing', 800.00, 3),
(105, 'Grocery', '2024-03-05', 'Delivered', 100.00, 4),
(106, 'Electronics', '2024-03-10', 'Shipped', 1200.00, 5),
(107, 'Books', '2024-03-15', 'Pending', 75.00, 2),
(108, 'Clothing', '2024-03-18', 'Delivered', 300.00, 6),
(109, 'Electronics', '2024-03-20', 'Processing', 950.00, 7),
(110, 'Furniture', '2024-03-25', 'Shipped', 750.00, 8);
```

---

‚úÖ a. TRIGGER TO MAINTAIN LOG ON DELETE OPERATION

SQL Server Syntax:

```sql
-- Create Log table
CREATE TABLE Order_Delete_Log (
    log_id INT IDENTITY(1,1) PRIMARY KEY,
    order_id INT NOT NULL,
    product_type VARCHAR(50),
    delivery_date DATE,
    status VARCHAR(20),
    amtpaid DECIMAL(10, 2),
    cust_id INT,
    deleted_by VARCHAR(100) DEFAULT SYSTEM_USER,
    deleted_at DATETIME DEFAULT GETDATE(),
    ip_address VARCHAR(50) DEFAULT NULL
);

-- Create Trigger
CREATE TRIGGER trg_order_delete_log
ON "Order"
AFTER DELETE
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Insert deleted records into log table
    INSERT INTO Order_Delete_Log 
    (order_id, product_type, delivery_date, status, amtpaid, cust_id)
    SELECT 
        d.order_id,
        d.product_type,
        d.delivery_date,
        d.status,
        d.amtpaid,
        d.cust_id
    FROM deleted d;
    
    -- Optional: Log additional information
    PRINT CAST(@@ROWCOUNT AS VARCHAR) + ' order(s) deleted and logged.';
END;
GO
```

MySQL Syntax:

```sql
-- Create Log table
CREATE TABLE Order_Delete_Log (
    log_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    product_type VARCHAR(50),
    delivery_date DATE,
    status VARCHAR(20),
    amtpaid DECIMAL(10, 2),
    cust_id INT,
    deleted_by VARCHAR(100) DEFAULT CURRENT_USER,
    deleted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create Trigger
DELIMITER $$

CREATE TRIGGER trg_order_delete_log
AFTER DELETE ON `Order`
FOR EACH ROW
BEGIN
    INSERT INTO Order_Delete_Log 
    (order_id, product_type, delivery_date, status, amtpaid, cust_id)
    VALUES (
        OLD.order_id,
        OLD.product_type,
        OLD.delivery_date,
        OLD.status,
        OLD.amtpaid,
        OLD.cust_id
    );
    
    -- Optional: Log to console
    SELECT CONCAT('Order ', OLD.order_id, ' deleted and logged') AS Message;
END$$

DELIMITER ;
```

PostgreSQL Syntax:

```sql
-- Create Log table
CREATE TABLE Order_Delete_Log (
    log_id SERIAL PRIMARY KEY,
    order_id INT NOT NULL,
    product_type VARCHAR(50),
    delivery_date DATE,
    status VARCHAR(20),
    amtpaid DECIMAL(10, 2),
    cust_id INT,
    deleted_by VARCHAR(100) DEFAULT CURRENT_USER,
    deleted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create Trigger Function
CREATE OR REPLACE FUNCTION log_deleted_order()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO Order_Delete_Log 
    (order_id, product_type, delivery_date, status, amtpaid, cust_id)
    VALUES (
        OLD.order_id,
        OLD.product_type,
        OLD.delivery_date,
        OLD.status,
        OLD.amtpaid,
        OLD.cust_id
    );
    
    RAISE NOTICE 'Order % deleted and logged', OLD.order_id;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- Create Trigger
CREATE TRIGGER trg_order_delete_log
AFTER DELETE ON "Order"
FOR EACH ROW
EXECUTE FUNCTION log_deleted_order();
```

Testing the Trigger:

```sql
-- View current orders
SELECT * FROM "Order" ORDER BY order_id;

-- Delete some orders to test trigger
DELETE FROM "Order" WHERE order_id = 107;
DELETE FROM "Order" WHERE status = 'Pending';

-- View the log table
SELECT * FROM Order_Delete_Log ORDER BY deleted_at DESC;

-- Verify orders are deleted
SELECT * FROM "Order" ORDER BY order_id;
```

---

‚úÖ b. DISPLAY CUSTOMERS WHOSE EMAIL HAS 'a' AS SECOND LETTER

Solution 1: Using LIKE with Underscore Wildcard

```sql
SELECT 
    cust_id AS Customer_ID,
    cust_name AS Customer_Name,
    email AS Email,
    city AS City
FROM Customer
WHERE email LIKE '_a%'
ORDER BY cust_name;
```

Solution 2: Using SUBSTRING Function

```sql
SELECT 
    cust_id,
    cust_name,
    email,
    city
FROM Customer
WHERE SUBSTRING(email, 2, 1) = 'a'
ORDER BY cust_name;
```

Solution 3: Using Regular Expressions

```sql
-- MySQL
SELECT cust_id, cust_name, email, city
FROM Customer
WHERE email REGEXP '^.a';

-- PostgreSQL
SELECT cust_id, cust_name, email, city
FROM Customer
WHERE email ~ '^.a';

-- SQL Server (2016+)
SELECT cust_id, cust_name, email, city
FROM Customer
WHERE email LIKE '_a%';
```

Solution 4: Case-Insensitive Search

```sql
-- For case-insensitive search
SELECT 
    cust_id,
    cust_name,
    email,
    city
FROM Customer
WHERE LOWER(SUBSTRING(email, 2, 1)) = 'a'
ORDER BY cust_name;
```

Expected Output:

```
Customer_ID | Customer_Name | Email                  | City
-----------|---------------|------------------------|------------
8          | Amanda Clark  | aclark@email.com      | San Diego
4          | Alice Williams| alice.w@example.com   | Houston
2          | Sarah Johnson | sarahj@yahoo.com      | Los Angeles
5          | Robert Davis  | rdavis@gmail.com      | Phoenix
7          | David Taylor  | dtaylor@demo.com      | San Antonio
1          | John Smith    | jsmith@gmail.com      | New York
```

---

‚úÖ c. DISPLAY CUST_IDS OF CUSTOMERS WHO HAVEN'T PLACED ANY ORDER

Solution 1: Using LEFT JOIN

```sql
SELECT 
    c.cust_id AS Customer_ID,
    c.cust_name AS Customer_Name,
    c.email AS Email,
    c.city AS City
FROM Customer c
LEFT JOIN "Order" o ON c.cust_id = o.cust_id
WHERE o.order_id IS NULL
ORDER BY c.cust_id;
```

Solution 2: Using NOT EXISTS

```sql
SELECT 
    cust_id,
    cust_name,
    email,
    city
FROM Customer c
WHERE NOT EXISTS (
    SELECT 1
    FROM "Order" o
    WHERE o.cust_id = c.cust_id
)
ORDER BY cust_id;
```

Solution 3: Using NOT IN

```sql
SELECT 
    cust_id,
    cust_name,
    email,
    city
FROM Customer
WHERE cust_id NOT IN (
    SELECT DISTINCT cust_id
    FROM "Order"
    WHERE cust_id IS NOT NULL  -- Important to avoid NULL issues
)
ORDER BY cust_id;
```

Solution 4: Using EXCEPT (Set Operation)

```sql
-- SQL Server, PostgreSQL
SELECT cust_id FROM Customer
EXCEPT
SELECT cust_id FROM "Order"
ORDER BY cust_id;

-- With customer details
SELECT 
    c.cust_id,
    c.cust_name,
    c.email,
    c.city
FROM Customer c
WHERE c.cust_id IN (
    SELECT cust_id FROM Customer
    EXCEPT
    SELECT cust_id FROM "Order"
)
ORDER BY cust_id;
```

Expected Output:

```
Customer_ID | Customer_Name | Email                | City
-----------|---------------|----------------------|---------
9          | Frank Miller  | fmiller@domain.com   | Dallas
10         | Grace Lee     | glee@server.com      | Austin
```

---

‚úÖ d. APPLY 5% DISCOUNT ON 'AMTPAID' FOR ALL CUSTOMERS

Solution 1: Simple UPDATE

```sql
-- Before discount
SELECT 
    order_id,
    cust_id,
    amtpaid AS Original_Amount,
    ROUND(amtpaid * 0.95, 2) AS Discounted_Amount,
    ROUND(amtpaid * 0.05, 2) AS Discount_Amount
FROM "Order"
ORDER BY order_id;

-- Apply 5% discount (reduce by 5%)
UPDATE "Order"
SET amtpaid = ROUND(amtpaid * 0.95, 2);

-- After discount
SELECT 
    order_id,
    cust_id,
    amtpaid AS Discounted_Amount
FROM "Order"
ORDER BY order_id;
```

Solution 2: UPDATE with Backup

```sql
-- Create backup table
SELECT * INTO Order_Backup FROM "Order";

-- Apply discount
UPDATE "Order"
SET amtpaid = ROUND(amtpaid * (1 - 0.05), 2);

-- Verify changes
SELECT 
    o.order_id,
    o.cust_id,
    b.amtpaid AS Original_Amount,
    o.amtpaid AS Discounted_Amount,
    ROUND(b.amtpaid - o.amtpaid, 2) AS Discount_Given
FROM "Order" o
JOIN Order_Backup b ON o.order_id = b.order_id
ORDER BY o.order_id;
```

Solution 3: UPDATE with Transaction

```sql
-- Use transaction for safety
BEGIN TRANSACTION;

-- Apply discount
UPDATE "Order"
SET amtpaid = ROUND(amtpaid * 0.95, 2);

-- Verify the update
SELECT 
    SUM(amtpaid) AS Total_After_Discount,
    COUNT(*) AS Total_Orders
FROM "Order";

-- If satisfied, commit
COMMIT;
-- If not satisfied, rollback: ROLLBACK;
```

Solution 4: UPDATE with CASE (Conditional Discount)

```sql
-- Apply discount only to specific orders (if needed)
UPDATE "Order"
SET amtpaid = 
    CASE 
        WHEN amtpaid > 500 THEN ROUND(amtpaid * 0.95, 2)  -- 5% discount for orders > 500
        WHEN amtpaid > 200 THEN ROUND(amtpaid * 0.98, 2)  -- 2% discount for orders > 200
        ELSE amtpaid                                       -- No discount for small orders
    END;

-- Show discount applied
SELECT 
    order_id,
    cust_id,
    amtpaid AS Final_Amount,
    CASE 
        WHEN amtpaid > 500 THEN '5% Discount'
        WHEN amtpaid > 200 THEN '2% Discount'
        ELSE 'No Discount'
    END AS Discount_Type
FROM "Order"
ORDER BY order_id;
```

Solution 5: Calculate Total Discount Given

```sql
-- Calculate total discount amount
SELECT 
    COUNT(*) AS Total_Orders,
    SUM(amtpaid) AS Total_After_Discount,
    SUM(amtpaid / 0.95) - SUM(amtpaid) AS Total_Discount_Given,
    ROUND(AVG(amtpaid), 2) AS Average_Order_Amount
FROM "Order";
```

---

üìä ADDITIONAL QUERIES FOR COMPREHENSIVE ANALYSIS

1. Customer Order Summary

```sql
SELECT 
    c.cust_id,
    c.cust_name,
    c.city,
    COUNT(o.order_id) AS Total_Orders,
    COALESCE(SUM(o.amtpaid), 0) AS Total_Amount,
    ROUND(AVG(o.amtpaid), 2) AS Average_Order_Value,
    MAX(o.delivery_date) AS Latest_Order_Date
FROM Customer c
LEFT JOIN "Order" o ON c.cust_id = o.cust_id
GROUP BY c.cust_id, c.cust_name, c.city
ORDER BY Total_Amount DESC;
```

2. Order Status Distribution

```sql
SELECT 
    status,
    COUNT(*) AS Order_Count,
    SUM(amtpaid) AS Total_Amount,
    ROUND(AVG(amtpaid), 2) AS Average_Amount
FROM "Order"
GROUP BY status
ORDER BY Order_Count DESC;
```

3. Monthly Order Analysis

```sql
SELECT 
    FORMAT(delivery_date, 'yyyy-MM') AS Month,
    COUNT(*) AS Order_Count,
    SUM(amtpaid) AS Total_Revenue,
    ROUND(AVG(amtpaid), 2) AS Average_Order_Value
FROM "Order"
WHERE delivery_date IS NOT NULL
GROUP BY FORMAT(delivery_date, 'yyyy-MM')
ORDER BY Month;
```

4. Top Customers by Spending

```sql
SELECT TOP 5
    c.cust_name,
    c.city,
    COUNT(o.order_id) AS Orders_Placed,
    SUM(o.amtpaid) AS Total_Spent,
    ROUND(SUM(o.amtpaid) / COUNT(o.order_id), 2) AS Avg_Order_Value
FROM Customer c
JOIN "Order" o ON c.cust_id = o.cust_id
GROUP BY c.cust_name, c.city
ORDER BY Total_Spent DESC;
```

5. Enhanced Trigger with More Details

```sql
-- Enhanced log table with more columns
CREATE TABLE Order_Audit_Log (
    audit_id INT IDENTITY(1,1) PRIMARY KEY,
    order_id INT NOT NULL,
    operation_type VARCHAR(10),  -- DELETE, UPDATE
    old_status VARCHAR(20),
    new_status VARCHAR(20),
    old_amount DECIMAL(10,2),
    new_amount DECIMAL(10,2),
    changed_by VARCHAR(100) DEFAULT SYSTEM_USER,
    changed_at DATETIME DEFAULT GETDATE(),
    ip_address VARCHAR(50)
);

-- Enhanced trigger for both DELETE and UPDATE
CREATE TRIGGER trg_order_audit
ON "Order"
AFTER DELETE, UPDATE
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Handle DELETE operations
    IF EXISTS (SELECT 1 FROM deleted) AND NOT EXISTS (SELECT 1 FROM inserted)
    BEGIN
        INSERT INTO Order_Audit_Log 
        (order_id, operation_type, old_status, old_amount)
        SELECT 
            d.order_id,
            'DELETE',
            d.status,
            d.amtpaid
        FROM deleted d;
    END
    
    -- Handle UPDATE operations
    IF EXISTS (SELECT 1 FROM deleted) AND EXISTS (SELECT 1 FROM inserted)
    BEGIN
        INSERT INTO Order_Audit_Log 
        (order_id, operation_type, old_status, new_status, old_amount, new_amount)
        SELECT 
            d.order_id,
            'UPDATE',
            d.status,
            i.status,
            d.amtpaid,
            i.amtpaid
        FROM deleted d
        JOIN inserted i ON d.order_id = i.order_id
        WHERE d.status <> i.status OR d.amtpaid <> i.amtpaid;
    END
END;
GO
```

6. View All Orders with Customer Details

```sql
SELECT 
    o.order_id,
    o.product_type,
    o.delivery_date,
    o.status,
    o.amtpaid,
    c.cust_name,
    c.email,
    c.city,
    CASE 
        WHEN o.amtpaid > 1000 THEN 'Premium'
        WHEN o.amtpaid > 500 THEN 'Standard'
        ELSE 'Basic'
    END AS Order_Category
FROM "Order" o
JOIN Customer c ON o.cust_id = c.cust_id
ORDER BY o.delivery_date DESC;
```

---

üîß DATABASE MAINTENANCE QUERIES

1. Reset Data After Testing

```sql
-- Delete test deletions
DELETE FROM Order_Delete_Log;

-- Reset orders to original amounts
UPDATE "Order"
SET amtpaid = 
    CASE order_id
        WHEN 101 THEN 500.00
        WHEN 102 THEN 150.00
        WHEN 103 THEN 200.00
        WHEN 104 THEN 800.00
        WHEN 105 THEN 100.00
        WHEN 106 THEN 1200.00
        WHEN 107 THEN 75.00
        WHEN 108 THEN 300.00
        WHEN 109 THEN 950.00
        WHEN 110 THEN 750.00
    END
WHERE order_id BETWEEN 101 AND 110;
```

2. Create Indexes for Performance

```sql
-- Create indexes on frequently queried columns
CREATE INDEX idx_customer_email ON Customer(email);
CREATE INDEX idx_order_cust_id ON "Order"(cust_id);
CREATE INDEX idx_order_status ON "Order"(status);
CREATE INDEX idx_order_delivery_date ON "Order"(delivery_date);
CREATE INDEX idx_order_amtpaid ON "Order"(amtpaid);
```

3. Database Health Check

```sql
-- Check table sizes
SELECT 
    OBJECT_NAME(object_id) AS Table_Name,
    SUM(row_count) AS Total_Rows,
    SUM(reserved_page_count) * 8 / 1024 AS Size_MB
FROM sys.dm_db_partition_stats
WHERE OBJECT_NAME(object_id) IN ('Customer', 'Order', 'Order_Delete_Log')
GROUP BY object_id;

-- Check foreign key relationships
SELECT 
    fk.name AS Foreign_Key,
    OBJECT_NAME(fk.parent_object_id) AS Child_Table,
    OBJECT_NAME(fk.referenced_object_id) AS Parent_Table
FROM sys.foreign_keys fk
WHERE OBJECT_NAME(fk.referenced_object_id) = 'Customer';
```

---

üìã SUMMARY OF SOLUTIONS

Task Solution Key Concepts Used
a. Delete Trigger CREATE TRIGGER, AFTER DELETE, deleted table Triggers, Audit logging
b. Email pattern LIKE '_a%', SUBSTRING() Pattern matching, String functions
c. Customers without orders LEFT JOIN, IS NULL, NOT EXISTS Joins, Subqueries, Set operations
d. Apply discount UPDATE, SET amtpaid = amtpaid * 0.95 Data modification, Arithmetic operations

---

üéØ KEY TAKEAWAYS

1. Triggers are essential for maintaining audit trails and data integrity
2. Pattern matching with LIKE and wildcards is powerful for data extraction
3. JOIN operations with IS NULL checks are key for finding missing relationships
4. UPDATE statements can include mathematical operations for bulk modifications
5. Always backup or use transactions before bulk data modifications
6. Create indexes on frequently queried columns for better performance
7. Document your database with comments on triggers and constraints

---

‚ö†Ô∏è TROUBLESHOOTING TIPS

1. If trigger doesn't fire:
   ¬∑ Check trigger event timing (AFTER vs INSTEAD OF)
   ¬∑ Verify trigger is enabled
   ¬∑ Check for syntax errors in trigger definition
2. If LIKE pattern doesn't match expected emails:
   ¬∑ Check case sensitivity (use LOWER() if needed)
   ¬∑ Verify there are no spaces in email addresses
   ¬∑ Test pattern with sample data first
3. If JOIN returns unexpected NULL results:
   ¬∑ Use COALESCE() or ISNULL() to handle NULL values
   ¬∑ Check foreign key relationships
   ¬∑ Verify data types match in JOIN conditions
4. If UPDATE affects wrong rows:
   ¬∑ Always test with SELECT first
   ¬∑ Use WHERE clause carefully
   ¬∑ Implement transactions for rollback capability

This comprehensive solution provides all required functionality with robust implementations across different database systems and includes additional useful queries for database management and analysis.
